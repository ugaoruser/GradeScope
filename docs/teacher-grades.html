<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Teacher Grade Management — GradeTracker</title>
  <link rel="icon" href="../favicon.ico" type="image/x-icon" sizes="any">
  <link rel="shortcut icon" href="../favicon.ico" type="image/x-icon">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=Pacifico&display=swap" rel="preload" as="style" onload="this.onload=null;this.rel='stylesheet'">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/remixicon/4.5.0/remixicon.min.css">
  <link rel="stylesheet" href="styles.css">
  <script src="config.js" defer></script>
  <script src="chatbot.js" defer></script>
  <script src="app.js" defer></script>
</head>
<body class="teacher-grades-page">
  <header class="header">
    <div class="header-title" id="subjectTitle">Subject Grades</div>
    <div class="account-menu" style="display:flex; align-items:center; gap:10px;">
      <span id="teacherName"></span>
      <button class="account-btn" id="accountBtnT"><span id="accountInitial">T</span></button>
      <div class="account-dropdown" id="accountDropdown" aria-hidden="true">
        <div class="account-info">
          <div id="userFullName">User Name</div>
          <div id="userEmail"></div>
        </div>
        <button id="logoutBtnT" class="logout-btn">Log Out</button>
      </div>
    </div>
    
  </header>
  
  <div class="main" style="padding: 20px; max-width: 1500px; margin: 0 auto;">
    <hr style="border: none; border-top: 1px solid #e2e8f0; margin: 0 0 24px 0;">
    <button class="back-btn" onclick="goBack()">← Back to Classes</button>
    
    <!-- Quarter Selection Card -->
    <div class="control-card">
      <h3 class="control-card-title">Academic Quarter</h3>
      <div class="quarter-tabs" id="quarterTabs">
        <button class="tab-button active" data-quarter="1" onclick="switchQuarter(1)">Quarter 1</button>
        <button class="tab-button" data-quarter="2" onclick="switchQuarter(2)">Quarter 2</button>
        <button class="tab-button" data-quarter="3" onclick="switchQuarter(3)">Quarter 3</button>
        <button class="tab-button" data-quarter="4" onclick="switchQuarter(4)">Quarter 4</button>
      </div>
    </div>
    
    <!-- Student Record Table (legacy hidden) -->
    <div class="student-record-container" style="display:none;">
      <div class="record-header">
        <h2>Student Grade Record - <span id="subjectTitleDisplay">Subject</span></h2>
        <div class="record-actions"></div>
      </div>
      
      <div class="table-wrapper">
        <table class="student-record-table" id="studentRecordTable">
          <thead>
            <tr>
              <th rowspan="2">Student Name</th>
              <th colspan="3">Performance Tasks (<span id="ptWeightDisplay">50</span>%)</th>
              <th colspan="3">Written Works (<span id="wwWeightDisplay">30</span>%)</th>
              <th colspan="2">Periodical Exam (<span id="peWeightDisplay">20</span>%)</th>
              <th rowspan="2">Initial Grade</th>
              <th rowspan="2">Quarterly Grade</th>
              <th rowspan="2">Comments</th>
              <th rowspan="2">Actions</th>
            </tr>
            <tr>
              <th>Score</th>
              <th>Max</th>
              <th>%</th>
              <th>Score</th>
              <th>Max</th>
              <th>%</th>
              <th>Score</th>
              <th>%</th>
            </tr>
          </thead>
          <tbody id="studentRecordBody">
            <tr><td colspan="13" class="loading-text">Loading students...</td></tr>
          </tbody>
        </table>
      </div>
    </div>
    
    <!-- Chatbot Toggle Button -->
    <button id="chatbotToggle" style="position: fixed; right: 24px; bottom: 24px; width: 56px; height: 56px; border-radius: 50%; background:#1976d2; color:#fff; border:none; box-shadow: 0 4px 10px rgba(0,0,0,0.2); cursor:pointer; font-size:24px; display: flex; align-items: center; justify-content: center;" aria-label="Chat">
      <i class="ri-message-3-line"></i>
    </button>
    <!-- Chatbot Sidebar -->
    <div id="chatbotSidebar" style="position: fixed; right: -360px; top: 0; width: 360px; height: 100%; background: #fff; box-shadow: -2px 0 10px rgba(0,0,0,0.1); transition: right 0.3s ease; z-index: 1000; display:flex; flex-direction:column;">
      <div style="padding: 12px 16px; border-bottom:1px solid #eee; display:flex; justify-content:space-between; align-items:center;">
        <div style="font-weight:600;">Assistant</div>
        <button id="closeChatbot" style="background:none; border:none; font-size:20px; cursor:pointer;">&times;</button>
      </div>
      <div id="chatLog" style="flex:1; padding: 12px; overflow:auto;">
        <div style="color:#666;">I can help you draft comments and estimate student progress. Ask me something like "Create a comment for Maria in Algebra, score 82" or "Average of 78, 85, 90".</div>
      </div>
      <div style="padding: 12px; border-top:1px solid #eee; display:flex; gap:8px;">
        <input id="chatInput" placeholder="Type a message..." style="flex:1; padding:10px; border:1px solid #ddd; border-radius:6px;">
        <button id="sendChat" style="padding:10px 14px; background:#1976d2; color:#fff; border:none; border-radius:6px; cursor:pointer;">Send</button>
      </div>
    </div>
    
    <!-- Tabs for Graded Components and Formative Assessment -->
    <div class="tabs" style="margin: 20px 0;">
      <div class="tab active" data-tab="graded">Graded Components</div>
      <div class="tab" data-tab="assessment">Formative Assessment</div>
    </div>
    
    <div id="gradedContent" class="tab-content active">
      <!-- Grade Category Weights Section -->
    <div class="grade-weights-card">
      <h2>Grade Category Weights</h2>
      <div class="weights-grid">
        <div class="weight-input-group">
          <label for="weightPT">Performance Task (%):</label>
          <input type="number" id="weightPT" min="0" max="100" value="50">
        </div>
        <div class="weight-input-group">
          <label for="weightWW">Written Works (%):</label>
          <input type="number" id="weightWW" min="0" max="100" value="30">
        </div>
        <div class="weight-input-group">
          <label for="weightPE">Periodical Exam (%):</label>
          <input type="number" id="weightPE" min="0" max="100" value="20">
        </div>
      </div>
      <div class="weights-footer">
        <div class="total-weight">
          <span>Total: <strong id="totalWeight">100%</strong></span>
        </div>
        <button class="btn-primary save-weights" onclick="saveWeights()" id="saveWeightsBtn">Save Weights</button>
      </div>
    </div>
    
    <!-- Category Switch and Table -->
    <div class="category-entry-container">
      <div class="category-header">
        <h2>Grade Entry - <span id="categoryTitleDisplay">Written Works</span></h2>
        <div class="category-tabs" id="categoryTabs">
          <button class="tab-button active" data-category="Written Works" onclick="switchCategory('Written Works')">Written Works</button>
          <button class="tab-button" data-category="Performance Task" onclick="switchCategory('Performance Task')">Performance Task</button>
          <button class="tab-button" data-category="Periodical Exam" onclick="switchCategory('Periodical Exam')">Periodical Exam</button>
        </div>
      </div>
      
      <div class="table-wrapper">
        <table class="category-record-table" id="categoryRecordTable">
          <thead id="categoryTableHead">
            <!-- Dynamically rendered -->
          </thead>
          <tbody id="categoryTableBody">
            <tr><td colspan="10" class="loading-text">Loading grade items...</td></tr>
          </tbody>
        </table>
      </div>
      
      <div class="category-pager" id="categoryPager">
        <!-- Dynamically rendered -->
      </div>
      
      <div class="category-helper">
        <small><strong>Note:</strong> Initial Grade and Quarterly Grade are overall grades across all categories, not just the active category.</small>
      </div>
      <div class="category-actions">
        <div class="category-legend">
          <small><strong>PS</strong> = Percentage Score, <strong>WS</strong> = Weighted Score.</small>
        </div>
        <button class="btn-primary save-category" onclick="saveAllCategoryGrades()">Save Grades</button>
      </div>
    </div>
    
    <!-- Formative Assessment Tab Content -->
    <div id="assessmentContent" class="tab-content">
      <div class="category-entry-container">
        <div class="category-header">
          <h2>Formative Assessment</h2>
        </div>
        
        <div class="table-wrapper">
          <table class="category-record-table">
            <thead>
              <tr>
                <th rowspan="2">Student Name</th>
                <th>Index No.</th>
                <th>Topic(s) of Task</th>
                <th>Score</th>
                <th>Highest Possible Score</th>
                <th>Comments</th>
              </tr>
            </thead>
            <tbody id="formativeAssessmentTable">
              <tr><td colspan="6" class="loading-text">Loading formative assessments...</td></tr>
            </tbody>
          </table>
        </div>
        
        <div class="category-pager" id="formativePager">
          <!-- Will be populated dynamically -->
        </div>
      </div>
    </div>
  </div>
  
  <script>
    // Tab switching functionality
    document.querySelectorAll('.tab').forEach(tab => {
      tab.addEventListener('click', () => {
        // Update active tab
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        tab.classList.add('active');
        
        // Show corresponding content
        const tabName = tab.getAttribute('data-tab');
        document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
        document.getElementById(tabName + 'Content').classList.add('active');
      });
    });
    
    // --- Student Record System ---
    let currentQuarter = 1;
    let subjectId = '';
    let subjectName = '';
    let students = [];
    let gradeWeights = { pt: 50, ww: 30, pe: 20 };
    
    // ---------- Category table state ----------
    let currentCategory = 'Written Works';
    let itemsByCategory = { 'Written Works': [], 'Performance Task': [], 'Periodical Exam': [] };
    let currentPage = 1; // 5 items per page => 10 columns (score/max pairs)
    let gradeCategories = [];
    let gradeItems = [];
    let scoresByKey = {}; // key: `${itemId}:${studentId}` -> number
    let commentsByKey = {};
    let scoresLoaded = false;

    function switchCategory(name){
      currentCategory = name;
      const el = document.getElementById('categoryTitleDisplay'); if (el) el.textContent = name;
      document.querySelectorAll('#categoryTabs .tab-button').forEach(btn=>{
        if (btn.dataset.category === name) btn.classList.add('active'); else btn.classList.remove('active');
      });
      currentPage = 1;
      computeItemsByCategory();
      renderCategoryTable();
    }

    function computeItemsByCategory(){
      try{
        const by = { 'Written Works': [], 'Performance Task': [], 'Periodical Exam': [] };
        (Array.isArray(gradeItems)? gradeItems : []).forEach(it=>{
          const catName = it.category_name || (gradeCategories||[]).find(c=> c.id === it.category_id)?.name;
          if (by[catName]) by[catName].push(it);
        });
        Object.keys(by).forEach(k=>{ by[k].sort((a,b)=> (new Date(a.date_assigned||0)) - (new Date(b.date_assigned||0))); });
        itemsByCategory = by;
      }catch(e){ itemsByCategory = { 'Written Works': [], 'Performance Task': [], 'Periodical Exam': [] }; }
    }

    function pagedItems(){
      const all = itemsByCategory[currentCategory] || [];
      const pageSize = (currentCategory === 'Periodical Exam') ? 1 : 5;
      const start = (currentPage-1)*pageSize;
      return all.slice(start, start+pageSize);
    }

    function totalPages(){
      const all = itemsByCategory[currentCategory] || [];
      const pageSize = (currentCategory === 'Periodical Exam') ? 1 : 5;
      return Math.max(1, Math.ceil(all.length / pageSize));
    }

    function gotoPage(p){
      const tp = totalPages();
      currentPage = Math.min(tp, Math.max(1, p));
      renderCategoryTable();
    }

    function renderPager(){
      const pager = document.getElementById('categoryPager');
      if (!pager) return;
      const tp = totalPages();
      if (tp <= 1){ pager.innerHTML = ''; return; }
      let html = `<button class="btn-secondary" ${currentPage===1?'disabled':''} onclick="gotoPage(${currentPage-1})">Prev</button>`;
      for (let i=1;i<=tp;i++){
        html += `<button class="btn-secondary ${i===currentPage?'active':''}" onclick="gotoPage(${i})">${i}</button>`;
      }
      html += `<button class="btn-secondary" ${currentPage===tp?'disabled':''} onclick="gotoPage(${currentPage+1})">Next</button>`;
      pager.innerHTML = html;
    }

    async function renderCategoryTable(){
      computeItemsByCategory();
      const head = document.getElementById('categoryTableHead');
      const body = document.getElementById('categoryTableBody');
      if (!head || !body) return;
      
      // Initialize history if this is the first render
      if (changeHistory.length === 0 && historyIndex === -1) {
        addToHistory('Initial state');
      }
      const allItems = itemsByCategory[currentCategory] || [];
      const pageItems = pagedItems();
      const pageSize = (currentCategory === 'Periodical Exam') ? 1 : 5;
      const visibleCols = pageItems.length; // actual item columns on this page
      const startIndex = (currentPage-1) * pageSize;

      // Ensure scores are loaded once students and items are available (non-blocking)
      if (!scoresLoaded && students && students.length && gradeItems && gradeItems.length){
        // kick off async load without blocking UI; re-render when done
        loadAllScores().then(()=>{ 
          try{ 
            // Mark that scores are loaded to prevent re-initialization conflicts
            if (!scoresLoaded) {
              scoresLoaded = true;
              renderCategoryTable(); 
            }
          }catch{} 
        });
      }

      const catLabel = currentCategory;
      let headRow1 = `<tr>`;
      headRow1 += `<th rowspan="2">Student Name</th>`;
      // Category-specific columns (items + Total, PS, WS)
      headRow1 += `<th colspan="${visibleCols + 3}">${catLabel}</th>`;
      // Overall grade columns (computed across all categories)
      headRow1 += `<th colspan="2">Overall Grade</th>`;
      headRow1 += `<th rowspan="2">Comments</th>`;
      headRow1 += `</tr>`;

      let headRow2 = `<tr>`;
      for (let i=0;i<visibleCols;i++){
        const it = pageItems[i];
        if (it){
          const colIndex = startIndex + i + 1;
          headRow2 += `<th data-item="${it.id}"><div class="header-number">${colIndex}</div></th>`;
        }
      }
      headRow2 += `<th>Total</th><th>PS</th><th>WS</th>`;
      headRow2 += `<th>Initial</th><th>Quarterly</th>`;
      headRow2 += `</tr>`;
      head.innerHTML = headRow1 + headRow2;

      if (!students || students.length === 0){
        const totalCols = visibleCols + 7; // Student Name + items + Total/PS/WS + Overall Initial/Quarterly + Comments
        body.innerHTML = `<tr><td colspan="${totalCols}" class="empty-text">No students enrolled</td></tr>`;
        renderPager();
        return;
      }
      body.innerHTML = '';

      // Build Highest Possible Score row (max scores per item)
      const maxRow = document.createElement('tr');
      let maxRowHtml = `<td class="student-name" style="font-weight:600;">Highest Possible Score</td>`;
      const maxByItem = {};
      pageItems.forEach(it=>{ if (it) maxByItem[it.id] = Number(it.max_score)||0; });
      for (let i=0;i<visibleCols;i++){
        const it = pageItems[i];
        if (it){
          const storedMax = Number(it.max_score);
          const displayVal = (Number.isFinite(storedMax) && storedMax > 0) ? storedMax : '';
          maxRowHtml += `<td class="max-cell" data-item="${it.id}"><input type="number" class="max-input-cell" data-item="${it.id}" min="0" value="${displayVal}"></td>`;
        }
      }
      const totalMaxAll = (allItems||[]).reduce((acc,it)=> acc + (Number(it.max_score)||0), 0);
      const catWeight = (function(){
        if (currentCategory === 'Performance Task') return Number(gradeWeights?.pt)||0;
        if (currentCategory === 'Written Works') return Number(gradeWeights?.ww)||0;
        if (currentCategory === 'Periodical Exam') return Number(gradeWeights?.pe)||0;
        try{
          const c = (gradeCategories||[]).find(x=>x && x.name===currentCategory);
          return Number(c?.weight)||0;
        }catch{return 0;}
      })();
      maxRowHtml += `<td>${totalMaxAll}</td><td>100%</td><td>${catWeight}%</td>`;
      // Placeholders so this row aligns under the Overall Grade and Comments columns
      maxRowHtml += `<td></td><td></td><td></td>`;
      maxRow.innerHTML = maxRowHtml;
      body.appendChild(maxRow);

      students.forEach(stu=>{
        const tr = document.createElement('tr');
        tr.dataset.studentId = String(stu.id);
        const name = stu.full_name || stu.name || 'Unknown Student';
        let row = `<td class="student-name"><div class="student-info"><div class="student-avatar">${name.charAt(0).toUpperCase()}</div><div>${name}</div></div></td>`;
        // One editable cell per item on the page
        for (let i=0;i<visibleCols;i++){
          const it = pageItems[i];
          if (it){
            const itemId = it.id;
            const key = `${itemId}:${stu.id}`;
            const val = scoresByKey[key] != null ? String(scoresByKey[key]) : '';
            row += `<td class="score-cell" data-item="${itemId}" data-student="${stu.id}"><input type="number" class="score-input-cell" data-item="${itemId}" data-student="${stu.id}" min="0" value="${val}"></td>`;
          }
        }
        // Totals for the entire category (across all items)
        const allItemIds = (allItems||[]).map(x=>x.id);
        let sumScores = 0;
        allItemIds.forEach(id=>{
          const k = `${id}:${stu.id}`;
          const v = Number(scoresByKey[k]);
          sumScores += Number.isFinite(v) ? v : 0;
        });
        const ps = totalMaxAll>0 ? (sumScores/totalMaxAll)*100 : 0;
        const ws = (ps * catWeight) / 100;
        row += `<td>${sumScores} / ${totalMaxAll}</td>`;
        row += `<td>${ps.toFixed(2)}%</td>`;
        row += `<td>${ws.toFixed(2)}</td>`;

        const ig =  (function(){ try{ return Number(calculateInitialGrade(stu.grades||{pt:{score:0,max:100},ww:{score:0,max:100},pe:{score:0,max:100}})||0);}catch{return 0;} })();
        const qg = (function(){ try{ return Number(transmuteGrade ? transmuteGrade(ig) : ig)||0;}catch{return ig;} })();
        row += `<td class="initial-grade">${ig.toFixed(2)}</td>`;
        row += `<td class="quarterly-grade">${qg.toFixed(2)}</td>`;
        const comm = (function(){
          // Try per-item comment if available in scores map later; default to empty
          const primaryItemId = (pageItems[0] && pageItems[0].id) || '';
          const key = primaryItemId ? `${primaryItemId}:${stu.id}` : null;
          if (key && commentsByKey && Object.prototype.hasOwnProperty.call(commentsByKey, key)){
            return String(commentsByKey[key] || '').slice(0,25);
          }
          return (stu.comment||'').toString().slice(0,25);
        })();
        row += `<td class="comment-cell" data-student="${stu.id}" data-item="${(pageItems[0]&&pageItems[0].id)||''}"><input type="text" class="comment-input-cell" maxlength="255" data-student="${stu.id}" data-item="${(pageItems[0]&&pageItems[0].id)||''}" value="${comm}"></td>`;
        tr.innerHTML = row;
        body.appendChild(tr);
      });
      renderPager();

      // Delegate editing handlers for score/comment/header/max cells (inputs)
      body.removeEventListener('change', onCellChange, true);
      body.addEventListener('change', onCellChange, true);
      head.removeEventListener('change', onCellChange, true);
      head.addEventListener('change', onCellChange, true);
      
      // Add Excel-like keyboard navigation
      body.removeEventListener('keydown', onCellKeyDown, true);
      body.addEventListener('keydown', onCellKeyDown, true);
      head.removeEventListener('keydown', onCellKeyDown, true);
      head.addEventListener('keydown', onCellKeyDown, true);
      
      // Add Excel-like copy/paste functionality
      body.removeEventListener('copy', onCellCopy, true);
      body.addEventListener('copy', onCellCopy, true);
      body.removeEventListener('paste', onCellPaste, true);
      body.addEventListener('paste', onCellPaste, true);

      // Update summary placeholder (optional hook for future computed summary)
      updateTeacherGradeSummary({ final: null, completion: 0 });
    }

    // Teacher summary updater (mirrors student view visuals)
    function updateTeacherGradeSummary(summary){
      try{
        const finalGradeEl = document.getElementById('tFinalGrade');
        const fill = document.getElementById('tProgressFill');
        const text = document.getElementById('tProgressText');
        const note = document.getElementById('tCompletionNote');
        const val = (summary && typeof summary.final === 'number') ? Number(summary.final).toFixed(2) : 'N/A';
        const comp = Math.max(0, Math.min(100, Number(summary?.completion||0)));
        if (finalGradeEl) finalGradeEl.textContent = val;
        if (fill) fill.style.width = comp + '%';
        if (text) text.textContent = comp + '% Complete';
        if (note){
          if (comp < 100){
            note.textContent = `Current completion: ${comp}%. This grade will change as more assignments are added and graded.`;
            note.style.color = '#dc2626';
          } else {
            note.textContent = `All assignments for this quarter are complete (${comp}%). This is the final grade for the quarter.`;
            note.style.color = '#059669';
          }
        }
        if (finalGradeEl && val !== 'N/A'){
          const g = parseFloat(val);
          let color = '#059669';
          if (g < 75) color = '#dc2626'; else if (g < 85) color = '#f59e0b';
          finalGradeEl.style.color = color;
        }
      }catch{}
    }

    // Formula evaluation engine
    function evaluateFormula(formula, studentId, itemId) {
      if (!formula || typeof formula !== 'string') return null;
      
      // Remove leading = if present
      formula = formula.trim();
      if (formula.startsWith('=')) {
        formula = formula.substring(1);
      }
      
      // Basic arithmetic operations
      try {
        // Replace cell references with actual values
        // Format: A1, B2, etc. (column letter + row number)
        formula = formula.replace(/([A-Z])(\d+)/gi, (match, col, row) => {
          const colIndex = col.toUpperCase().charCodeAt(0) - 'A'.charCodeAt(0);
          const rowIndex = parseInt(row) - 1;
          
          // Get the actual cell value from the table
          const tbody = document.getElementById('categoryTableBody');
          if (tbody) {
            const rows = Array.from(tbody.querySelectorAll('tr'));
            if (rowIndex >= 0 && rowIndex < rows.length) {
              const cells = Array.from(rows[rowIndex].querySelectorAll('td'));
              if (colIndex >= 0 && colIndex < cells.length) {
                const input = cells[colIndex].querySelector('input.score-input-cell');
                if (input) {
                  const val = parseFloat(input.value) || 0;
                  return val.toString();
                }
              }
            }
          }
          return '0';
        });
        
        // Replace SUM, AVERAGE, MIN, MAX functions
        formula = formula.replace(/SUM\(([^)]+)\)/gi, (match, range) => {
          return evaluateSumRange(range, studentId);
        });
        
        formula = formula.replace(/AVERAGE\(([^)]+)\)/gi, (match, range) => {
          const sum = evaluateSumRange(range, studentId);
          const count = countCellsInRange(range);
          return count > 0 ? (sum / count).toString() : '0';
        });
        
        formula = formula.replace(/MIN\(([^)]+)\)/gi, (match, range) => {
          return evaluateMinMaxRange(range, studentId, true);
        });
        
        formula = formula.replace(/MAX\(([^)]+)\)/gi, (match, range) => {
          return evaluateMinMaxRange(range, studentId, false);
        });
        
        // Evaluate the resulting expression
        // Use Function constructor for safer evaluation than eval
        const result = new Function('return ' + formula)();
        
        if (typeof result === 'number' && isFinite(result)) {
          return result;
        }
      } catch (error) {
        console.warn('Formula evaluation error:', error);
      }
      
      return null;
    }
    
    function evaluateSumRange(range, studentId) {
      // Parse range like A1:B3 or A1,A2,A3
      const cells = parseRange(range, studentId);
      let sum = 0;
      cells.forEach(cell => {
        const val = parseFloat(cell.value) || 0;
        sum += val;
      });
      return sum.toString();
    }
    
    function countCellsInRange(range, studentId) {
      const cells = parseRange(range, studentId);
      return cells.length;
    }
    
    function evaluateMinMaxRange(range, studentId, isMin) {
      const cells = parseRange(range, studentId);
      if (cells.length === 0) return '0';
      
      let result = parseFloat(cells[0].value) || 0;
      cells.forEach(cell => {
        const val = parseFloat(cell.value) || 0;
        if (isMin && val < result) result = val;
        if (!isMin && val > result) result = val;
      });
      
      return result.toString();
    }
    
    function parseRange(range, studentId) {
      const cells = [];
      const tbody = document.getElementById('categoryTableBody');
      if (!tbody) return cells;
      
      // Handle single cell like A1
      if (/^[A-Z]\d+$/i.test(range.trim())) {
        const match = range.trim().match(/([A-Z])(\d+)/i);
        if (match) {
          const colIndex = match[1].toUpperCase().charCodeAt(0) - 'A'.charCodeAt(0);
          const rowIndex = parseInt(match[2]) - 1;
          const cell = getCellAtPosition(tbody, rowIndex, colIndex);
          if (cell) cells.push(cell);
        }
      }
      // Handle range like A1:B3
      else if (/^[A-Z]\d*:[A-Z]\d*$/i.test(range.trim())) {
        const parts = range.trim().split(':');
        const startMatch = parts[0].match(/([A-Z])(\d*)/i);
        const endMatch = parts[1].match(/([A-Z])(\d*)/i);
        
        if (startMatch && endMatch) {
          const startCol = startMatch[1].toUpperCase().charCodeAt(0) - 'A'.charCodeAt(0);
          const startRow = startMatch[2] ? parseInt(startMatch[2]) - 1 : 0;
          const endCol = endMatch[1].toUpperCase().charCodeAt(0) - 'A'.charCodeAt(0);
          const endRow = endMatch[2] ? parseInt(endMatch[2]) - 1 : Number.MAX_SAFE_INTEGER;
          
          for (let r = startRow; r <= endRow; r++) {
            for (let c = startCol; c <= endCol; c++) {
              const cell = getCellAtPosition(tbody, r, c);
              if (cell) cells.push(cell);
            }
          }
        }
      }
      // Handle comma-separated list like A1,A2,B3
      else if (range.includes(',')) {
        const parts = range.split(',');
        parts.forEach(part => {
          const match = part.trim().match(/([A-Z])(\d+)/i);
          if (match) {
            const colIndex = match[1].toUpperCase().charCodeAt(0) - 'A'.charCodeAt(0);
            const rowIndex = parseInt(match[2]) - 1;
            const cell = getCellAtPosition(tbody, rowIndex, colIndex);
            if (cell) cells.push(cell);
          }
        });
      }
      
      return cells;
    }
    
    function getCellAtPosition(tbody, rowIndex, colIndex) {
      const rows = Array.from(tbody.querySelectorAll('tr'));
      if (rowIndex >= 0 && rowIndex < rows.length) {
        const cells = Array.from(rows[rowIndex].querySelectorAll('td'));
        if (colIndex >= 0 && colIndex < cells.length) {
          const input = cells[colIndex].querySelector('input.score-input-cell');
          return input;
        }
      }
      return null;
    }
    
    // Recompute all formulas in the table
    function recomputeFormulas() {
      const tbody = document.getElementById('categoryTableBody');
      if (!tbody) return;
      
      const formulaCells = Array.from(tbody.querySelectorAll('input[data-formula]'));
      formulaCells.forEach(input => {
        const formula = input.getAttribute('data-formula');
        const studentId = Number(input.getAttribute('data-student'));
        const itemId = Number(input.getAttribute('data-item'));
        
        if (formula && studentId && itemId) {
          const result = evaluateFormula(formula, studentId, itemId);
          if (result !== null) {
            const oldValue = parseFloat(input.value) || 0;
            input.value = String(result);
            scoresByKey[`${itemId}:${studentId}`] = result;
            
            // Auto-save the computed formula result (but mark as formula computation to prevent loops)
            if (subjectId && window.API_BASE && oldValue !== result) {
              input.setAttribute('data-formula-computing', 'true');
              fetch(`${window.API_BASE}/api/subjects/${subjectId}/scores`, {
                method: 'POST', headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ grade_item_id: itemId, student_id: studentId, score: result })
              }).then(() => {
                input.removeAttribute('data-formula-computing');
              }).catch(err => {
                input.removeAttribute('data-formula-computing');
                console.warn('Formula save failed', err);
              });
            }
          }
        }
      });
    }
    
    // Undo/Redo functionality
    let changeHistory = [];
    let historyIndex = -1;
    const MAX_HISTORY_SIZE = 50;
    
    function addToHistory(action) {
      // Remove any history after current index (for new actions after undo)
      changeHistory = changeHistory.slice(0, historyIndex + 1);
      
      // Add new action
      changeHistory.push({
        timestamp: Date.now(),
        action: action,
        state: {
          scores: {...scoresByKey},
          comments: {...commentsByKey},
          formulas: getCurrentFormulas()
        }
      });
      
      // Limit history size
      if (changeHistory.length > MAX_HISTORY_SIZE) {
        changeHistory.shift();
      } else {
        historyIndex++;
      }
    }
    
    function getCurrentFormulas() {
      const formulas = {};
      const tbody = document.getElementById('categoryTableBody');
      if (tbody) {
        const formulaCells = Array.from(tbody.querySelectorAll('input[data-formula]'));
        formulaCells.forEach(input => {
          const studentId = input.getAttribute('data-student');
          const itemId = input.getAttribute('data-item');
          const formula = input.getAttribute('data-formula');
          if (studentId && itemId && formula) {
            formulas[`${itemId}:${studentId}`] = formula;
          }
        });
      }
      return formulas;
    }
    
    function restoreState(state) {
      if (!state) return;
      
      // Restore scores
      scoresByKey = {...state.scores};
      
      // Restore comments
      commentsByKey = {...state.comments};
      
      // Restore formulas and update values directly without full re-render
      if (state.formulas) {
        Object.keys(state.formulas).forEach(key => {
          const [itemId, studentId] = key.split(':');
          const input = document.querySelector(`input.score-input-cell[data-item="${itemId}"][data-student="${studentId}"]`);
          if (input) {
            input.setAttribute('data-formula', state.formulas[key]);
            input.title = `Formula: ${state.formulas[key]}`;
            // Re-evaluate the formula
            const result = evaluateFormula(state.formulas[key], Number(studentId), Number(itemId));
            if (result !== null) {
              input.value = String(result);
            }
          }
        });
      }
      
      // Update existing input values without full re-render
      const tbody = document.getElementById('categoryTableBody');
      if (tbody) {
        const scoreInputs = tbody.querySelectorAll('input.score-input-cell');
        scoreInputs.forEach(input => {
          const studentId = input.getAttribute('data-student');
          const itemId = input.getAttribute('data-item');
          const score = scoresByKey[`${itemId}:${studentId}`];
          if (score !== undefined && !input.hasAttribute('data-formula')) {
            input.value = String(score);
          }
        });
        
        const commentInputs = tbody.querySelectorAll('input.comment-input-cell');
        commentInputs.forEach(input => {
          const studentId = input.getAttribute('data-student');
          const itemId = input.getAttribute('data-item');
          const comment = commentsByKey[`${itemId}:${studentId}`];
          if (comment !== undefined) {
            input.value = comment;
          }
        });
      }
    }
    
    function undo() {
      if (historyIndex > 0) {
        historyIndex--;
        const previousState = changeHistory[historyIndex].state;
        restoreState(previousState);
        return true;
      }
      return false;
    }
    
    function redo() {
      if (historyIndex < changeHistory.length - 1) {
        historyIndex++;
        const nextState = changeHistory[historyIndex].state;
        restoreState(nextState);
        return true;
      }
      return false;
    }
    
    // Add keyboard shortcuts for undo/redo
    document.addEventListener('keydown', function(e) {
      // Only handle undo/redo when not typing in input fields
      const target = e.target;
      const isInput = target.matches('input, textarea');
      
      // Ctrl+Z for undo
      if (e.ctrlKey && e.key === 'z' && !e.shiftKey && !isInput) {
        e.preventDefault();
        if (undo()) {
          showUndoRedoFeedback('Undo');
        }
      }
      // Ctrl+Y or Ctrl+Shift+Z for redo
      else if (((e.ctrlKey && e.key === 'y') || (e.ctrlKey && e.shiftKey && e.key === 'z')) && !isInput) {
        e.preventDefault();
        if (redo()) {
          showUndoRedoFeedback('Redo');
        }
      }
    });
    
    function showUndoRedoFeedback(action) {
      // Create temporary feedback element
      const feedback = document.createElement('div');
      feedback.textContent = action;
      feedback.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: #4f46e5;
        color: white;
        padding: 8px 16px;
        border-radius: 4px;
        font-weight: bold;
        z-index: 10000;
        box-shadow: 0 4px 6px rgba(0,0,0,0.1);
      `;
      document.body.appendChild(feedback);
      
      setTimeout(() => {
        if (feedback.parentNode) {
          feedback.parentNode.removeChild(feedback);
        }
      }, 1500);
    }

    async function onCellChange(e){
      const t = e.target;
      if (!t) return;
      
      // Skip if this change is from formula computation (prevent loops)
      if (t.hasAttribute('data-formula-computing')) {
        return;
      }
      
      // Store current state for undo before making changes
      const oldScore = scoresByKey[`${t.getAttribute('data-item')}:${t.getAttribute('data-student')}`];
      const oldComment = commentsByKey[`${t.getAttribute('data-item')}:${t.getAttribute('data-student')}`];
      
      // Show saving indicator
      const cell = t.closest('td');
      if (cell) {
        cell.classList.add('saving');
        cell.classList.remove('save-error', 'save-success');
      }
      
      // Score input
      if (t.classList.contains('score-input-cell')){
        const studentId = Number(t.getAttribute('data-student'));
        const itemId = Number(t.getAttribute('data-item'));
        let raw = (t.value || '').trim();
        
        // Check if this is a formula
        let v = null;
        if (raw.startsWith('=')) {
          // Evaluate formula
          v = evaluateFormula(raw, studentId, itemId);
          if (v !== null) {
            // Store the formula in a data attribute
            t.setAttribute('data-formula', raw);
            t.title = `Formula: ${raw}`;
          } else {
            // Invalid formula, show error
            if (cell) {
              cell.classList.remove('saving');
              cell.classList.add('save-error');
              setTimeout(() => cell.classList.remove('save-error'), 3000);
            }
            return;
          }
        } else {
          // Regular numeric input
          if (raw === '') raw = '0';
          v = Number(raw);
          if (!Number.isFinite(v) || v < 0) v = 0;
          // Clear formula if it existed
          t.removeAttribute('data-formula');
          t.title = '';
        }
        
        // Validate against max
        const item = (gradeItems || []).find(x=> Number(x.id)===itemId);
        const maxScore = Number(item?.max_score) || 0;
        if (maxScore && v > maxScore) v = maxScore;
        
        // Reflect normalized value in UI
        t.value = String(v);
        scoresByKey[`${itemId}:${studentId}`] = v;
        
        // Auto-save with visual feedback
        if (subjectId && window.API_BASE){
          try{
            const payload = { grade_item_id: itemId, student_id: studentId, score: v };
            const response = await fetch(`${window.API_BASE}/api/subjects/${subjectId}/scores`, {
              method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload)
            });
            
            if (response.ok) {
              // Show success feedback
              if (cell) {
                cell.classList.remove('saving');
                cell.classList.add('save-success');
                setTimeout(() => cell.classList.remove('save-success'), 1500);
              }
              
              // Add to history if value actually changed
              if (oldScore !== v) {
                addToHistory(`Score changed: ${oldScore} → ${v}`);
              }
            } else {
              throw new Error('Save failed');
            }
          }catch(err){ 
            console.warn('Save failed', err);
            // Show error feedback
            if (cell) {
              cell.classList.remove('saving');
              cell.classList.add('save-error');
              setTimeout(() => cell.classList.remove('save-error'), 3000);
            }
          }
        }
        // Recompute formulas (this will handle totals automatically)
        recomputeFormulas();
      }
      // Comment input
      else if (t.classList.contains('comment-input-cell')){
        const studentId = Number(t.getAttribute('data-student'));
        const itemId = Number(t.getAttribute('data-item'));
        const val = (t.value||'').slice(0,255);
        if (t.value !== val) t.value = val;
        commentsByKey[`${itemId}:${studentId}`] = val;
        
        // Auto-save with visual feedback
        if (subjectId && window.API_BASE){
          try{
            // Find existing score for this student/item to include in payload
            const score = scoresByKey[`${itemId}:${studentId}`] || 0;
            const payload = { grade_item_id: itemId, student_id: studentId, score, comments: val };
            const response = await fetch(`${window.API_BASE}/api/subjects/${subjectId}/scores`, {
              method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload)
            });
            
            if (response.ok) {
              // Show success feedback
              if (cell) {
                cell.classList.remove('saving');
                cell.classList.add('save-success');
                setTimeout(() => cell.classList.remove('save-success'), 1500);
              }
              
              // Add to history if comment actually changed
              if (oldComment !== val) {
                addToHistory(`Comment changed: "${oldComment}" → "${val}"`);
              }
            } else {
              throw new Error('Save failed');
            }
          }catch(err){ 
            console.warn('Save comment failed', err);
            // Show error feedback
            if (cell) {
              cell.classList.remove('saving');
              cell.classList.add('save-error');
              setTimeout(() => cell.classList.remove('save-error'), 3000);
            }
          }
        }
      }
      // Max score input (per item)
      else if (t.classList.contains('max-input-cell')){
        const itemId = Number(t.getAttribute('data-item'));
        let raw = (t.value || '').trim();
        if (raw === '') raw = '0';
        let v = Number(raw);
        if (!Number.isFinite(v) || v < 0) v = 0;
        t.value = String(v);
        // Persist via items update API, including existing fields to avoid clobbering
        try{
          const it = (gradeItems||[]).find(x=> Number(x.id)===itemId);
          if (subjectId && window.API_BASE && it){
            const payload = { items: [{
              id: it.id,
              categoryId: it.category_id,
              title: it.title,
              topic: it.topic,
              itemType: it.item_type,
              includedInFinal: !!it.included_in_final,
              maxScore: v,
              dateAssigned: it.date_assigned
            }]};
            await fetch(`${window.API_BASE}/api/subjects/${subjectId}/items`, {
              method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload)
            });
            // Update local copy and re-render
            it.max_score = v;
            computeItemsByCategory();
            renderCategoryTable();
          }
        }catch(err){ console.warn('Save max score failed', err); }
      }
    }
    
    // Excel-like keyboard navigation
    function onCellKeyDown(e) {
      const t = e.target;
      if (!t || !t.matches('input.score-input-cell, input.comment-input-cell, input.max-input-cell')) return;
      
      const key = e.key;
      const isArrow = ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(key);
      const isTab = key === 'Tab';
      const isEnter = key === 'Enter';
      
      if (!isArrow && !isTab && !isEnter) return;
      
      e.preventDefault();
      
      // Get current cell position
      const currentCell = t.closest('td');
      const currentRow = currentCell.closest('tr');
      const tbody = currentRow.closest('tbody');
      const allRows = Array.from(tbody.querySelectorAll('tr'));
      const currentRowIndex = allRows.indexOf(currentRow);
      const allCells = Array.from(currentRow.querySelectorAll('td'));
      const currentCellIndex = allCells.indexOf(currentCell);
      
      let targetCell = null;
      
      if (key === 'ArrowUp' && currentRowIndex > 0) {
        const targetRow = allRows[currentRowIndex - 1];
        targetCell = targetRow.querySelectorAll('td')[currentCellIndex];
      } else if (key === 'ArrowDown' && currentRowIndex < allRows.length - 1) {
        const targetRow = allRows[currentRowIndex + 1];
        targetCell = targetRow.querySelectorAll('td')[currentCellIndex];
      } else if (key === 'ArrowLeft' && currentCellIndex > 0) {
        targetCell = allCells[currentCellIndex - 1];
      } else if (key === 'ArrowRight' && currentCellIndex < allCells.length - 1) {
        targetCell = allCells[currentCellIndex + 1];
      } else if (isTab) {
        if (e.shiftKey) {
          // Shift+Tab: move to previous editable cell
          if (currentCellIndex > 0) {
            for (let i = currentCellIndex - 1; i >= 0; i--) {
              const cell = allCells[i];
              const input = cell.querySelector('input');
              if (input && !input.disabled) {
                targetCell = cell;
                break;
              }
            }
          }
          // If no previous cell in current row, go to last editable cell of previous row
          if (!targetCell && currentRowIndex > 0) {
            const prevRow = allRows[currentRowIndex - 1];
            const prevCells = Array.from(prevRow.querySelectorAll('td')).reverse();
            for (const cell of prevCells) {
              const input = cell.querySelector('input');
              if (input && !input.disabled) {
                targetCell = cell;
                break;
              }
            }
          }
        } else {
          // Tab: move to next editable cell
          if (currentCellIndex < allCells.length - 1) {
            for (let i = currentCellIndex + 1; i < allCells.length; i++) {
              const cell = allCells[i];
              const input = cell.querySelector('input');
              if (input && !input.disabled) {
                targetCell = cell;
                break;
              }
            }
          }
          // If no next cell in current row, go to first editable cell of next row
          if (!targetCell && currentRowIndex < allRows.length - 1) {
            const nextRow = allRows[currentRowIndex + 1];
            for (const cell of nextRow.querySelectorAll('td')) {
              const input = cell.querySelector('input');
              if (input && !input.disabled) {
                targetCell = cell;
                break;
              }
            }
          }
        }
      } else if (isEnter) {
        // Enter: move to next row, same column
        if (currentRowIndex < allRows.length - 1) {
          const targetRow = allRows[currentRowIndex + 1];
          targetCell = targetRow.querySelectorAll('td')[currentCellIndex];
        }
      }
      
      // Focus the target cell's input
      if (targetCell) {
        const targetInput = targetCell.querySelector('input');
        if (targetInput) {
          targetInput.focus();
          // Select all text for easy editing
          targetInput.select();
        }
      }
    }
    
    // Excel-like copy functionality
    function onCellCopy(e) {
      const t = e.target;
      if (!t || !t.matches('input.score-input-cell, input.comment-input-cell, input.max-input-cell')) return;
      
      // Get selection range
      const selection = window.getSelection();
      if (!selection.rangeCount) return;
      
      const range = selection.getRangeAt(0);
      const startCell = range.startContainer.closest('td');
      const endCell = range.endContainer.closest('td');
      
      if (!startCell || !endCell) return;
      
      // Get all cells in the selection
      const tbody = startCell.closest('tbody');
      const allRows = Array.from(tbody.querySelectorAll('tr'));
      const startRowIndex = allRows.indexOf(startCell.closest('tr'));
      const endRowIndex = allRows.indexOf(endCell.closest('tr'));
      const startCellIndex = Array.from(startCell.closest('tr').querySelectorAll('td')).indexOf(startCell);
      const endCellIndex = Array.from(endCell.closest('tr').querySelectorAll('td')).indexOf(endCell);
      
      const minRow = Math.min(startRowIndex, endRowIndex);
      const maxRow = Math.max(startRowIndex, endRowIndex);
      const minCol = Math.min(startCellIndex, endCellIndex);
      const maxCol = Math.max(startCellIndex, endCellIndex);
      
      // Build tab-separated values
      let copyData = '';
      for (let r = minRow; r <= maxRow; r++) {
        const row = allRows[r];
        const cells = Array.from(row.querySelectorAll('td'));
        const rowData = [];
        
        for (let c = minCol; c <= maxCol; c++) {
          const cell = cells[c];
          if (cell) {
            const input = cell.querySelector('input');
            if (input) {
              rowData.push(input.value || '');
            } else {
              rowData.push(cell.textContent.trim());
            }
          } else {
            rowData.push('');
          }
        }
        
        copyData += rowData.join('\t');
        if (r < maxRow) copyData += '\n';
      }
      
      e.preventDefault();
      e.clipboardData.setData('text/plain', copyData);
    }
    
    // Excel-like paste functionality
    function onCellPaste(e) {
      const t = e.target;
      if (!t || !t.matches('input.score-input-cell, input.comment-input-cell, input.max-input-cell')) return;
      
      e.preventDefault();
      
      const pasteData = e.clipboardData.getData('text/plain');
      if (!pasteData) return;
      
      // Parse tab-separated data
      const rows = pasteData.split('\n').map(row => row.split('\t'));
      if (rows.length === 0) return;
      
      // Get current cell position
      const currentCell = t.closest('td');
      const currentRow = currentCell.closest('tr');
      const tbody = currentRow.closest('tbody');
      const allRows = Array.from(tbody.querySelectorAll('tr'));
      const currentRowIndex = allRows.indexOf(currentRow);
      const allCells = Array.from(currentRow.querySelectorAll('td'));
      const currentCellIndex = allCells.indexOf(currentCell);
      
      // Paste data starting from current position
      for (let r = 0; r < rows.length && currentRowIndex + r < allRows.length; r++) {
        const targetRow = allRows[currentRowIndex + r];
        const targetCells = Array.from(targetRow.querySelectorAll('td'));
        const rowData = rows[r];
        
        for (let c = 0; c < rowData.length && currentCellIndex + c < targetCells.length; c++) {
          const targetCell = targetCells[currentCellIndex + c];
          const targetInput = targetCell.querySelector('input');
          
          if (targetInput && !targetInput.disabled) {
            const value = rowData[c];
            
            // Validate numeric inputs
            if (targetInput.matches('input.score-input-cell, input.max-input-cell')) {
              const numValue = parseFloat(value);
              if (!isNaN(numValue) && numValue >= 0) {
                // Check max score validation
                if (targetInput.matches('input.score-input-cell')) {
                  const itemId = Number(targetInput.getAttribute('data-item'));
                  const item = (gradeItems || []).find(x => Number(x.id) === itemId);
                  const maxScore = Number(item?.max_score) || 0;
                  if (maxScore && numValue > maxScore) {
                    // Skip invalid values
                    continue;
                  }
                }
                targetInput.value = numValue;
                // Trigger change event to save
                targetInput.dispatchEvent(new Event('change', { bubbles: true }));
              }
            } else if (targetInput.matches('input.comment-input-cell')) {
              targetInput.value = value.slice(0, 255);
              // Trigger change event to save
              targetInput.dispatchEvent(new Event('change', { bubbles: true }));
            }
          }
        }
      }
    }
    
    async function saveAllCategoryGrades() {
      const body = document.getElementById('categoryTableBody');
      if (!body || !students || !students.length) return;

      const savePromises = [];

      // Collect header labels for each visible item (numeric headers)
      const headEl = document.getElementById('categoryTableHead');
      const headerTitleByItem = {};
      if (headEl) {
        const headerInputs = Array.from(headEl.querySelectorAll('input.header-comment-input[data-item]'));
        for (const input of headerInputs) {
          const itemId = Number(input.getAttribute('data-item'));
          if (!itemId) continue;
          const val = (input.value || '').toString().slice(0, 120);
          if (input.value !== val) input.value = val;
          headerTitleByItem[itemId] = val;
        }
      }

      // Validate highest possible scores (max scores per visible item)
      const maxCells = Array.from(body.querySelectorAll('input.max-input-cell[data-item]'));
      const maxByItem = {};
      for (const cell of maxCells) {
        const itemId = Number(cell.getAttribute('data-item'));
        if (!itemId) continue;
        let raw = (cell.value || '').trim();
        // If left blank, treat as "no task yet" and skip this column
        if (raw === '') {
          continue;
        }
        let v = Number(raw);
        if (!Number.isFinite(v) || v <= 0) {
          alert('Highest possible score must be a positive number.');
          cell.focus();
          return;
        }
        cell.value = String(v);
        maxByItem[itemId] = v;
        const it = (gradeItems || []).find(x => Number(x.id) === itemId);
        if (it) {
          it.max_score = v;
        }
      }

      // Persist updated max scores and header titles for current page items
      if (subjectId && window.API_BASE) {
        const touchedIds = new Set([
          ...Object.keys(maxByItem).map(Number),
          ...Object.keys(headerTitleByItem).map(Number)
        ]);
        const itemsPayload = [];
        touchedIds.forEach(id => {
          if (!id) return;
          const it = (gradeItems || []).find(x => Number(x.id) === id);
          if (!it) return;
          const title = headerTitleByItem[id] != null ? headerTitleByItem[id] : (it.title || '');
          const maxScoreVal = maxByItem[id] != null ? maxByItem[id] : (Number(it.max_score) || 0);
          itemsPayload.push({
            id: it.id,
            categoryId: it.category_id,
            title,
            topic: it.topic,
            itemType: it.item_type,
            includedInFinal: !!it.included_in_final,
            maxScore: maxScoreVal,
            dateAssigned: it.date_assigned
          });
          it.title = title;
          it.max_score = maxScoreVal;
        });
        if (itemsPayload.length) {
          savePromises.push(
            fetch(`${window.API_BASE}/api/subjects/${subjectId}/items`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ items: itemsPayload })
            }).catch(err => console.warn('Save items (headers/max) failed', err))
          );
        }
      }

      // Normalize and save all visible scores and comments
      const scoreCells = Array.from(body.querySelectorAll('input.score-input-cell[data-item][data-student]'));
      for (const cell of scoreCells) {
        const itemId = Number(cell.getAttribute('data-item'));
        const studentId = Number(cell.getAttribute('data-student'));
        if (!itemId || !studentId) continue;
        let raw = (cell.value || '').trim();
        if (raw === '') raw = '0';
        let v = Number(raw);
        if (!Number.isFinite(v) || v < 0) v = 0;

        const maxScore = maxByItem[itemId] || Number(((gradeItems || []).find(x => Number(x.id) === itemId) || {}).max_score) || 0;
        // Do not allow positive scores when no highest possible score is defined yet
        if (!maxScore && v > 0) {
          alert('Set the highest possible score for this column before entering student scores.');
          cell.focus();
          return;
        }
        if (maxScore && v > maxScore) {
          alert(`Score for this column cannot exceed its highest possible score of ${maxScore}.`);
          cell.value = String(maxScore);
          cell.focus();
          return;
        }

        cell.value = String(v);
        scoresByKey[`${itemId}:${studentId}`] = v;

        if (subjectId && window.API_BASE) {
          const payload = { grade_item_id: itemId, student_id: studentId, score: v };
          savePromises.push(
            fetch(`${window.API_BASE}/api/subjects/${subjectId}/scores`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(payload)
            }).catch(err => console.warn('Save score failed', err))
          );
        }
      }

      const commentCells = Array.from(body.querySelectorAll('input.comment-input-cell[data-student]'));
      for (const cell of commentCells) {
        const studentId = Number(cell.getAttribute('data-student'));
        const itemId = Number(cell.getAttribute('data-item'));
        if (!studentId || !itemId) continue;
        const val = (cell.value || '').slice(0, 255);
        if (cell.value !== val) cell.value = val;

        if (subjectId && window.API_BASE) {
          const key = `${itemId}:${studentId}`;
          const cur = Number(scoresByKey[key]);
          const score = Number.isFinite(cur) ? cur : 0;
          commentsByKey[key] = val;
          const payload = { grade_item_id: itemId, student_id: studentId, score, comments: val };
          savePromises.push(
            fetch(`${window.API_BASE}/api/subjects/${subjectId}/scores`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(payload)
            }).catch(err => console.warn('Save comment failed', err))
          );
        }
      }

      await Promise.all(savePromises);

      // Aggregate per-student category totals for PT / WW / PE and save initial/quarterly grades
      const catById = {};
      (gradeCategories || []).forEach(c => { if (c && c.id != null) catById[c.id] = c; });

      (students || []).forEach(stu => {
        const totals = {
          pt: { score: 0, max: 0 },
          ww: { score: 0, max: 0 },
          pe: { score: 0, max: 0 }
        };

        (gradeItems || []).forEach(it => {
          if (!it || !it.included_in_final) return;
          const cat = catById[it.category_id];
          if (!cat) return;
          const key = `${it.id}:${stu.id}`;
          const sVal = Number(scoresByKey[key]);
          const mVal = Number(it.max_score) || 0;
          if (!Number.isFinite(sVal) || mVal <= 0) return;

          let bucket = null;
          if (cat.name === 'Performance Task') bucket = 'pt';
          else if (cat.name === 'Written Works') bucket = 'ww';
          else if (cat.name === 'Periodical Exam') bucket = 'pe';
          if (!bucket) return;

          totals[bucket].score += sVal;
          totals[bucket].max += mVal;
        });

        if (!stu.grades) {
          stu.grades = {
            pt: { score: 0, max: 100 },
            ww: { score: 0, max: 100 },
            pe: { score: 0, max: 100 }
          };
        }

        stu.grades.pt.score = totals.pt.score;
        stu.grades.pt.max = totals.pt.max || 1;
        stu.grades.ww.score = totals.ww.score;
        stu.grades.ww.max = totals.ww.max || 1;
        stu.grades.pe.score = totals.pe.score;
        stu.grades.pe.max = totals.pe.max || 1;

        const initialGrade = calculateInitialGrade(stu.grades);
        const quarterlyGrade = transmuteGrade(initialGrade);

        // Persist aggregated grades to backend
        saveStudentGrades(stu.id);

        // Update visible initial/quarterly grade cells for this row
        const row = body.querySelector(`tr[data-student-id="${stu.id}"]`);
        if (row) {
          const igCell = row.querySelector('td.initial-grade');
          const qgCell = row.querySelector('td.quarterly-grade');
          if (igCell) igCell.textContent = initialGrade.toFixed(2);
          if (qgCell) qgCell.textContent = quarterlyGrade.toFixed(2);
        }
      });

      alert('Grades saved successfully.');
    }
    
    // Grade transmutation table (DepEd standard)
    const transmutationTable = {
      100: 100, 99: 99, 98: 98, 97: 97, 96: 96, 95: 95,
      94: 94, 93: 93, 92: 92, 91: 91, 90: 90,
      89: 89, 88: 88, 87: 87, 86: 86, 85: 85,
      84: 84, 83: 83, 82: 82, 81: 81, 80: 80,
      79: 79, 78: 78, 77: 77, 76: 76, 75: 75,
      74: 74, 73: 73, 72: 72, 71: 71, 70: 70,
      69: 69, 68: 68, 67: 67, 66: 66, 65: 65,
      64: 64, 63: 63, 62: 62, 61: 61, 60: 60,
      59: 59, 58: 58, 57: 57, 56: 56, 55: 55,
      54: 54, 53: 53, 52: 52, 51: 51, 50: 50,
      49: 49, 48: 48, 47: 47, 46: 46, 45: 45,
      44: 44, 43: 43, 42: 42, 41: 41, 40: 40,
      39: 39, 38: 38, 37: 37, 36: 36, 35: 35,
      34: 34, 33: 33, 32: 32, 31: 31, 30: 30,
      29: 29, 28: 28, 27: 27, 26: 26, 25: 25,
      24: 24, 23: 23, 22: 22, 21: 21, 20: 20,
      19: 75, 18: 74, 17: 73, 16: 72, 15: 71,
      14: 70, 13: 69, 12: 68, 11: 67, 10: 66,
      9: 65, 8: 64, 7: 63, 6: 62, 5: 61,
      4: 60, 3: 60, 2: 60, 1: 60, 0: 60
    };
    
    // Initialize
    document.addEventListener('DOMContentLoaded', function() {
      const urlParams = new URLSearchParams(window.location.search);
      subjectId = urlParams.get('subjectId') || urlParams.get('id') || '';
      subjectName = urlParams.get('subjectName') || urlParams.get('name') || 'Subject';
      
      const subjTitle = document.getElementById('subjectTitle');
      const subjDisplay = document.getElementById('subjectTitleDisplay');
      if (subjTitle) subjTitle.textContent = subjectName;
      if (subjDisplay) subjDisplay.textContent = subjectName;
      
      loadGradeWeights();
      loadStudents();
      loadGradeCategories();
      loadGradeItems();
      // Initial category render
      computeItemsByCategory();
      renderCategoryTable();
      // Initialize teacher summary
      updateTeacherGradeSummary({ final: null, completion: 0 });
      
      // Setup weight input listeners
      ['weightPT', 'weightWW', 'weightPE'].forEach(id => {
        const input = document.getElementById(id);
        if (input) {
          input.addEventListener('input', updateWeightDisplay);
          input.addEventListener('change', saveWeights);
        }
      });
    });
    
    // Load grade weights
    function loadGradeWeights() {
      if (!window.API_BASE || !subjectId) return;
      
      fetch(`${window.API_BASE}/api/subjects/${subjectId}/categories?quarter=${currentQuarter}`)
        .then(res => res.json())
        .then(categories => {
          categories.forEach(cat => {
            if (cat.name === 'Performance Task') {
              gradeWeights.pt = cat.weight;
              document.getElementById('weightPT').value = cat.weight;
              document.getElementById('ptWeightDisplay').textContent = cat.weight;
            } else if (cat.name === 'Written Works') {
              gradeWeights.ww = cat.weight;
              document.getElementById('weightWW').value = cat.weight;
              document.getElementById('wwWeightDisplay').textContent = cat.weight;
            } else if (cat.name === 'Periodical Exam') {
              gradeWeights.pe = cat.weight;
              document.getElementById('weightPE').value = cat.weight;
              document.getElementById('peWeightDisplay').textContent = cat.weight;
            }
          });
          updateWeightDisplay();
        })
        .catch(err => console.error('Error loading weights:', err));
    }
    
    // Load students and render table
    function loadStudents() {
      if (!window.API_BASE || !subjectId) {
        console.error('Missing API_BASE or subjectId');
        return;
      }
      
      const tbody = document.getElementById('studentRecordBody');
      tbody.innerHTML = '<tr><td colspan="13" class="loading-text">Loading students...</td></tr>';
      
      fetch(`${window.API_BASE}/api/subjects/${subjectId}/students`)
        .then(res => res.json())
        .then(data => {
          students = Array.isArray(data) ? data : (data.students || []);
          renderStudentTable();
        })
        .catch(err => {
          console.error('Error loading students:', err);
          tbody.innerHTML = '<tr><td colspan="13" class="error-text">Failed to load students</td></tr>';
        });
    }

    async function loadAllScores(){
      try{
        const scoreMap = {};
        const commentMap = {};
        for (const s of (students||[])){
          const url = `${window.API_BASE}/api/subjects/${subjectId}/scores?student_id=${encodeURIComponent(s.id)}&quarter=${encodeURIComponent(currentQuarter)}`;
          const resp = await fetch(url, { headers: (typeof authHeaders==='function'? authHeaders():{}) });
          if (!resp.ok) continue;
          const rows = await resp.json();
          (rows||[]).forEach(r=>{
            const key = `${r.grade_item_id}:${s.id}`;
            scoreMap[key] = Number(r.score);
            if (r.comments != null) commentMap[key] = String(r.comments);
          });
        }
        scoresByKey = scoreMap;
        commentsByKey = commentMap;
        scoresLoaded = true;
      }catch(e){ scoresByKey = {}; commentsByKey = {}; scoresLoaded = true; }
    }
    
    // Render student record table
    function renderStudentTable() {
      const tbody = document.getElementById('studentRecordBody');
      
      if (students.length === 0) {
        tbody.innerHTML = '<tr><td colspan="13" class="empty-text">No students enrolled</td></tr>';
        return;
      }
      
      tbody.innerHTML = '';
      
      students.forEach((student, index) => {
        const row = document.createElement('tr');
        row.dataset.studentId = student.id;
        
        // Initialize student grades if not exists
        if (!student.grades) {
          student.grades = {
            pt: { score: 0, max: 100 },
            ww: { score: 0, max: 100 },
            pe: { score: 0, max: 100 }
          };
        }
        
        const initialGrade = calculateInitialGrade(student.grades);
        const quarterlyGrade = transmuteGrade(initialGrade);
        
        row.innerHTML = `
          <td class="student-name">
            <div class="student-info">
              <div class="student-avatar">${(student.full_name || student.name || 'Unknown').charAt(0).toUpperCase()}</div>
              <div>${student.full_name || student.name || 'Unknown Student'}</div>
            </div>
          </td>
          <td><input type="number" class="score-input pt-score" data-student="${student.id}" data-category="pt" value="${student.grades.pt.score}" min="0" max="${student.grades.pt.max}" onchange="updateStudentGrade(${student.id}, 'pt', this.value)"></td>
          <td><input type="number" class="max-input pt-max" data-student="${student.id}" data-category="pt" value="${student.grades.pt.max}" min="1" onchange="updateMaxScore(${student.id}, 'pt', this.value)"></td>
          <td class="percentage">${student.grades.pt.max > 0 ? ((student.grades.pt.score / student.grades.pt.max) * 100).toFixed(1) : '0.0'}%</td>
          <td><input type="number" class="score-input ww-score" data-student="${student.id}" data-category="ww" value="${student.grades.ww.score}" min="0" max="${student.grades.ww.max}" onchange="updateStudentGrade(${student.id}, 'ww', this.value)"></td>
          <td><input type="number" class="max-input ww-max" data-student="${student.id}" data-category="ww" value="${student.grades.ww.max}" min="1" onchange="updateMaxScore(${student.id}, 'ww', this.value)"></td>
          <td class="percentage">${student.grades.ww.max > 0 ? ((student.grades.ww.score / student.grades.ww.max) * 100).toFixed(1) : '0.0'}%</td>
          <td><input type="number" class="score-input pe-score" data-student="${student.id}" data-category="pe" value="${student.grades.pe.score}" min="0" max="${student.grades.pe.max}" onchange="updateStudentGrade(${student.id}, 'pe', this.value)"></td>
          <td class="percentage">${student.grades.pe.max > 0 ? ((student.grades.pe.score / student.grades.pe.max) * 100).toFixed(1) : '0.0'}%</td>
          <td class="initial-grade">${initialGrade.toFixed(2)}</td>
          <td class="quarterly-grade">${quarterlyGrade.toFixed(2)}</td>
          <td><input type="text" maxlength="25" class="comment-input" data-student="${student.id}" value="${(student.comment || '').toString().slice(0,25)}" placeholder="Add comment..." onchange="updateComment(${student.id}, this.value)"></td>
          <td class="actions">
            <button class="btn-delete" onclick="removeStudent(${student.id})">Remove</button>
          </td>
        `;
        
        tbody.appendChild(row);
      });
    }
    
    // Calculate initial grade from categories
    function calculateInitialGrade(grades) {
      const ptPercent = grades.pt.max > 0 ? (grades.pt.score / grades.pt.max) * 100 : 0;
      const wwPercent = grades.ww.max > 0 ? (grades.ww.score / grades.ww.max) * 100 : 0;
      const pePercent = grades.pe.max > 0 ? (grades.pe.score / grades.pe.max) * 100 : 0;
      
      const initialGrade = (ptPercent * gradeWeights.pt / 100) + 
                          (wwPercent * gradeWeights.ww / 100) + 
                          (pePercent * gradeWeights.pe / 100);
      
      return Math.min(100, Math.max(0, initialGrade));
    }
    
    // Transmute grade using DepEd table
    function transmuteGrade(initialGrade) {
      const rounded = Math.round(initialGrade);
      return transmutationTable[rounded] || 60;
    }
    
    // Update student grade
    function updateStudentGrade(studentId, category, score) {
      const student = students.find(s => s.id == studentId);
      if (!student) return;
      
      if (!student.grades) {
        student.grades = { pt: { score: 0, max: 100 }, ww: { score: 0, max: 100 }, pe: { score: 0, max: 100 } };
      }
      
      const numScore = parseFloat(score) || 0;
      const maxScore = student.grades[category].max;
      
      if (numScore > maxScore) {
        alert(`Score cannot exceed maximum score of ${maxScore}`);
        // Reset the input
        const input = document.querySelector(`input[data-student="${studentId}"][data-category="${category}"]`);
        if (input) input.value = student.grades[category].score;
        return;
      }
      
      student.grades[category].score = numScore;
      
      // Update display
      updateStudentRow(studentId);
      
      // Save to backend
      saveStudentGrades(studentId);
    }
    
    // Update max score
    function updateMaxScore(studentId, category, maxScore) {
      const student = students.find(s => s.id == studentId);
      if (!student) return;
      
      if (!student.grades) {
        student.grades = { pt: { score: 0, max: 100 }, ww: { score: 0, max: 100 }, pe: { score: 0, max: 100 } };
      }
      
      const numMax = parseFloat(maxScore) || 1;
      student.grades[category].max = numMax;
      
      // Adjust current score if it exceeds new max
      if (student.grades[category].score > numMax) {
        student.grades[category].score = numMax;
      }
      
      // Update input max attribute
      const scoreInput = document.querySelector(`input.score-input[data-student="${studentId}"][data-category="${category}"]`);
      if (scoreInput) {
        scoreInput.max = numMax;
        scoreInput.value = student.grades[category].score;
      }
      
      updateStudentRow(studentId);
      saveStudentGrades(studentId);
    }
    
    // Update student row display
    function updateStudentRow(studentId) {
      const student = students.find(s => s.id == studentId);
      if (!student) return;
      
      const row = document.querySelector(`tr[data-student-id="${studentId}"]`);
      if (!row) return;
      
      const initialGrade = calculateInitialGrade(student.grades);
      const quarterlyGrade = transmuteGrade(initialGrade);
      
      // Update percentages
      const ptPercent = student.grades.pt.max > 0 ? ((student.grades.pt.score / student.grades.pt.max) * 100).toFixed(1) : '0.0';
      const wwPercent = student.grades.ww.max > 0 ? ((student.grades.ww.score / student.grades.ww.max) * 100).toFixed(1) : '0.0';
      const pePercent = student.grades.pe.max > 0 ? ((student.grades.pe.score / student.grades.pe.max) * 100).toFixed(1) : '0.0';
      
      const cells = row.cells;
      cells[3].textContent = ptPercent + '%';  // PT %
      cells[6].textContent = wwPercent + '%';  // WW %
      cells[8].textContent = pePercent + '%';  // PE %
      cells[9].textContent = initialGrade.toFixed(2);  // Initial Grade
      cells[10].textContent = quarterlyGrade.toFixed(2); // Quarterly Grade
    }
    
    // Update comment (stored locally only)
    function updateComment(studentId, comment) {
      const student = students.find(s => s.id == studentId);
      if (student) {
        const trimmed = (comment || '').toString().slice(0,25);
        student.comment = trimmed;
      }
    }
    
    // Save student grades to backend
    function saveStudentGrades(studentId) {
      const student = students.find(s => s.id == studentId);
      if (!student || !window.API_BASE || !subjectId) return;
      
      const gradesData = {
        student_id: studentId,
        subject_id: subjectId,
        quarter: currentQuarter,
        grades: student.grades,
        comment: student.comment || '',
        initial_grade: calculateInitialGrade(student.grades),
        quarterly_grade: transmuteGrade(calculateInitialGrade(student.grades))
      };
      
      fetch(`${window.API_BASE}/api/student-grades`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(gradesData)
      })
      .catch(err => console.error('Error saving grades:', err));
    }
    
    // Switch quarter
    function switchQuarter(quarter) {
      // Update current quarter
      currentQuarter = quarter;
      
      // Update active tab UI
      document.querySelectorAll('.quarter-tabs .tab-button').forEach(btn => {
        if (parseInt(btn.dataset.quarter) === quarter) {
          btn.classList.add('active');
        } else {
          btn.classList.remove('active');
        }
      });
      
      // Clear existing data
      students = [];
      gradeItems = [];
      gradeCategories = [];
      scoresByKey = {};
      commentsByKey = {};
      itemsByCategory = { 'Written Works': [], 'Performance Task': [], 'Periodical Exam': [] };
      
      // Update UI to show loading state
      const tableBody = document.querySelector('#categoryTable tbody');
      if (tableBody) {
        tableBody.innerHTML = '<tr><td colspan="10" class="loading-text">Loading quarter data...</td></tr>';
      }
      
      // Reload all data for the new quarter
      Promise.all([
        loadStudents(),
        loadGradeWeights(),
        loadGradeCategories(),
        loadGradeItems(),
        loadFormativeAssessments()
      ]).then(() => {
        // Re-render the table after all data is loaded
        renderCategoryTable();
        renderStudentTable();
      }).catch(error => {
        console.error('Error loading quarter data:', error);
        if (tableBody) {
          tableBody.innerHTML = '<tr><td colspan="10" class="error-text">Error loading data. Please try again.</td></tr>';
        }
      });
    }
    
    // Update weight display
    function updateWeightDisplay() {
      const ptWeight = parseFloat(document.getElementById('weightPT').value) || 0;
      const wwWeight = parseFloat(document.getElementById('weightWW').value) || 0;
      const peWeight = parseFloat(document.getElementById('weightPE').value) || 0;
      const total = ptWeight + wwWeight + peWeight;
      
      document.getElementById('ptWeightDisplay').textContent = ptWeight;
      document.getElementById('wwWeightDisplay').textContent = wwWeight;
      document.getElementById('peWeightDisplay').textContent = peWeight;
      document.getElementById('totalWeight').textContent = total + '%';
      document.getElementById('totalWeight').style.color = total === 100 ? '#059669' : '#dc2626';
    }
    
    // Save weights
    function saveWeights() {
      if (!window.API_BASE || !subjectId) return;
      const pt = parseFloat(document.getElementById('weightPT').value) || 0;
      const ww = parseFloat(document.getElementById('weightWW').value) || 0;
      const pe = parseFloat(document.getElementById('weightPE').value) || 0;
      const categories = [
        { name: 'Performance Task', weight: pt, quarter: currentQuarter },
        { name: 'Written Works', weight: ww, quarter: currentQuarter },
        { name: 'Periodical Exam', weight: pe, quarter: currentQuarter },
      ];
      fetch(`${window.API_BASE}/api/subjects/${subjectId}/categories`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ categories })
      })
      .then(res => res.ok ? res.json() : Promise.reject(new Error('Failed to save weights')))
      .then(() => {
        gradeWeights = { pt, ww, pe };
        updateWeightDisplay();
        renderCategoryTable();
        // weights changed, re-show summary placeholder
        updateTeacherGradeSummary({ final: null, completion: 0 });
      })
      .catch(err => console.error('Error saving weights:', err));
    }
    
    function loadGradeCategories() {
      if (!window.API_BASE || !subjectId) {
        console.error('Missing API_BASE or subjectId. Aborting loadGradeItems.');
        return;
      }

      fetch(`${window.API_BASE}/api/subjects/${subjectId}/categories?quarter=${currentQuarter}`, { headers: (typeof authHeaders==='function'? authHeaders() : {}) })
      .then(res => {
        if (!res.ok) throw new Error('Failed to load grade categories');
        return res.json();
      })
      .then(data => {
        gradeCategories = data;
        
        // Update weight inputs
        const ptCategory = gradeCategories.find(cat => cat.name === 'Performance Task');
        const wwCategory = gradeCategories.find(cat => cat.name === 'Written Works');
        const peCategory = gradeCategories.find(cat => cat.name === 'Periodical Exam');
        
        if (ptCategory) document.getElementById('weightPT').value = ptCategory.weight;
        if (wwCategory) document.getElementById('weightWW').value = wwCategory.weight;
        if (peCategory) document.getElementById('weightPE').value = peCategory.weight;

        // Update displayed category weight labels in headers
        const ptW = document.getElementById('ptWeight');
        const wwW = document.getElementById('wwWeight');
        const peW = document.getElementById('peWeight');
        if (ptW && ptCategory) ptW.textContent = ptCategory.weight;
        if (wwW && wwCategory) wwW.textContent = wwCategory.weight;
        if (peW && peCategory) peW.textContent = peCategory.weight;
      })
      .catch(err => {
        console.error('Error loading grade categories:', err);
      });
    }

    function loadFormativeAssessments() {
      // This would be implemented to load formative assessment data
      // Similar to loadGradeItems but for non-graded assessments
      console.log('Loading formative assessments...');
      // TODO: Implement actual API call to fetch formative assessments
      // For now, we'll just show a message
      const tableBody = document.getElementById('formativeAssessmentTable');
      if (tableBody) {
        tableBody.innerHTML = '<tr><td colspan="6">No formative assessments found for this quarter.</td></tr>';
      }
    }

    function loadGradeItems() {
      if (!window.API_BASE || !subjectId) {
        console.error('Missing API_BASE or subjectId. Aborting loadGradeItems.');
        return;
      }
      const url = `${window.API_BASE}/api/subjects/${subjectId}/items?quarter=${currentQuarter}`;
      fetch(url, { headers: (typeof authHeaders==='function' ? authHeaders() : {}) })
        .then(res => res.ok ? res.json() : [])
        .then(data => {
          gradeItems = Array.isArray(data) ? data : (data.items || []);
          scoresLoaded = false; // force reload of scores when items change
          computeItemsByCategory();
          const len = (itemsByCategory[currentCategory] || []).length;
          const pageSize = (currentCategory === 'Periodical Exam') ? 1 : 5;
          if (len > 0 && len % pageSize === 1 && len > pageSize) {
            currentPage = totalPages();
          }
          renderCategoryTable();
        })
        .catch(err => {
          console.error('Error loading grade items:', err);
          gradeItems = [];
          computeItemsByCategory();
          renderCategoryTable();
        });
    }
    
    // Remove student
    function removeStudent(studentId) {
      if (!confirm('Are you sure you want to remove this student?')) return;
      
      students = students.filter(s => s.id !== studentId);
      renderStudentTable();
      
      // Remove from backend
      if (window.API_BASE && subjectId) {
        fetch(`${window.API_BASE}/api/subjects/${subjectId}/students/${studentId}`, {
          method: 'DELETE'
        })
        .catch(err => console.error('Error removing student:', err));
      }
    }
    
    // Export to Excel (placeholder)
    function exportToExcel() {
      alert('Excel export functionality would be implemented here');
    }
    
    // Navigation
    function goBack() {
      window.location.href = 'homepage2.html';
    }
    
    function logout() {
      localStorage.removeItem('token');
      localStorage.removeItem('role');
      localStorage.removeItem('userId');
      localStorage.removeItem('userName');
      window.location.href = 'login.html';
    }
  </script>  
  <style>
    /* Student Record Table Styles */
    .student-record-container {
      background: var(--card);
      border: 1px solid #e2e8f0;
      border-radius: 12px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
      overflow: hidden;
    }
    
    .record-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 20px 24px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
    }
    
    .record-header h2 {
      margin: 0;
      font-size: 1.3rem;
      font-weight: 600;
    }
    
    .record-actions {
      display: flex;
      gap: 12px;
    }
    
    .btn-primary {
      background: rgba(255, 255, 255, 0.2);
      color: white;
      border: 1px solid rgba(255, 255, 255, 0.3);
      padding: 8px 16px;
      border-radius: 6px;
      cursor: pointer;
      font-weight: 500;
      transition: all 0.2s ease;
    }
    
    .btn-primary:hover {
      background: rgba(255, 255, 255, 0.3);
      transform: translateY(-1px);
    }
    
    .btn-secondary {
      background: rgba(255, 255, 255, 0.1);
      color: white;
      border: 1px solid rgba(255, 255, 255, 0.2);
      padding: 8px 16px;
      border-radius: 6px;
      cursor: pointer;
      font-weight: 500;
      transition: all 0.2s ease;
    }
    
    .btn-secondary:hover {
      background: rgba(255, 255, 255, 0.2);
    }
    
    .table-wrapper {
      overflow-x: auto;
    }
    
    .student-record-table {
      width: 100%;
      border-collapse: collapse;
      background: var(--card);
    }
    
    .student-record-table th {
      background: #f8fafc;
      padding: 12px 8px;
      text-align: center;
      font-weight: 600;
      color: var(--text);
      border-bottom: 2px solid #e2e8f0;
      font-size: 0.85rem;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      vertical-align: middle;
    }
    
    .student-record-table th:first-child {
      text-align: left;
      padding-left: 16px;
    }
    
    .student-record-table td {
      padding: 12px 8px;
      border-bottom: 1px solid #f1f5f9;
      color: var(--text);
      vertical-align: middle;
      text-align: center;
    }
    
    .student-record-table td:first-child {
      text-align: left;
      padding-left: 16px;
    }
    
    .student-record-table tbody tr:hover {
      background: #f8fafc;
    }
    
    .student-info {
      display: flex;
      align-items: center;
      gap: 12px;
    }
    
    .student-avatar {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 600;
      font-size: 0.9rem;
    }
    
    .score-input, .max-input {
      width: 60px;
      padding: 6px 8px;
      border: 2px solid #e2e8f0;
      border-radius: 4px;
      text-align: center;
      font-size: 0.9rem;
      transition: all 0.2s ease;
    }
    
    .score-input:focus, .max-input:focus {
      outline: none;
      border-color: var(--primary);
      box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1);
    }
    
    .comment-input {
      width: 150px;
      padding: 6px 8px;
      border: 2px solid #e2e8f0;
      border-radius: 4px;
      font-size: 0.85rem;
      transition: all 0.2s ease;
    }
    
    .comment-input:focus {
      outline: none;
      border-color: var(--primary);
      box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1);
    }
    
    .percentage {
      font-weight: 600;
      color: #64748b;
      font-size: 0.85rem;
    }
    
    .initial-grade {
      font-weight: 700;
      color: #059669;
      font-size: 0.95rem;
    }
    
    .quarterly-grade {
      font-weight: 700;
      color: #7c3aed;
      font-size: 0.95rem;
    }
    
    .btn-delete {
      background: #ef4444;
      color: white;
      border: none;
      padding: 6px 12px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.8rem;
      font-weight: 500;
      transition: all 0.2s ease;
    }
    
    .btn-delete:hover {
      background: #dc2626;
      transform: translateY(-1px);
    }
    
    .loading-text, .error-text, .empty-text {
      text-align: center;
      padding: 40px;
      color: #64748b;
      font-style: italic;
    }
    
    .error-text {
      color: #ef4444;
    }
    
    /* Grade Weights Card Styles */
    .grade-weights-card {
      background: var(--card);
      border: 1px solid #e2e8f0;
      border-radius: 12px;
      padding: 24px;
      margin-bottom: 24px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
    }
    
    .grade-weights-card h2 {
      margin: 0 0 20px 0;
      font-size: 1.2rem;
      font-weight: 600;
      color: var(--text);
    }
    
    .weights-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 16px;
      margin-bottom: 20px;
    }
    
    .weight-input-group {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    
    .weight-input-group label {
      font-weight: 500;
      color: var(--text);
      font-size: 0.9rem;
    }
    
    .weight-input-group input {
      padding: 10px 12px;
      border: 2px solid #e2e8f0;
      border-radius: 6px;
      font-size: 0.95rem;
      transition: all 0.2s ease;
    }
    
    .weight-input-group input:focus {
      outline: none;
      border-color: var(--primary);
      box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1);
    }
    
    .weights-footer {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .total-weight {
      font-weight: 600;
      color: var(--text);
    }
    
    .save-weights {
      background: var(--primary);
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 6px;
      cursor: pointer;
      font-weight: 500;
      transition: all 0.2s ease;
    }
    
    .save-weights:hover {
      background: #4f46e5;
      transform: translateY(-1px);
    }
    .control-card {
      background: var(--card);
      border: 1px solid #e2e8f0;
      border-radius: 12px;
      padding: 24px;
      margin-bottom: 24px;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      transition: all 0.2s ease;
    }
    
    .control-card:hover {
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      transform: translateY(-1px);
    }
    
    .control-card-title {
      font-size: 1.1rem;
      font-weight: 600;
      color: var(--text);
      margin: 0 0 16px 0;
      display: flex;
      align-items: center;
    }
    
    .control-card-title::before {
      content: '';
      width: 4px;
      height: 20px;
      background: var(--primary);
      border-radius: 2px;
      margin-right: 12px;
    }
    
    .student-selector {
      display: flex;
      align-items: center;
      gap: 12px;
    }
    
    .selector-label {
      font-weight: 500;
      color: var(--text);
      min-width: 120px;
    }
    
    .student-select {
      flex: 1;
      padding: 10px 14px;
      border: 2px solid #e2e8f0;
      border-radius: 8px;
      background: var(--card);
      color: var(--text);
      font-size: 0.95rem;
      transition: all 0.2s ease;
    }
    
    .student-select:focus {
      outline: none;
      border-color: var(--primary);
      box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1);
    }
    
    .quarter-tabs {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }
    
    .quarter-tab {
      padding: 10px 18px;
      background: #f8fafc;
      border: 2px solid #e2e8f0;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s ease;
      font-weight: 500;
      color: var(--text-secondary);
    }
    
    .quarter-tab:hover {
      background: #f1f5f9;
      border-color: #cbd5e1;
    }
    
    .quarter-tab.active {
      background: var(--primary);
      border-color: var(--primary);
      color: white;
    }
    
    .tabs {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }
    
    .tab {
      padding: 12px 20px;
      background: #f8fafc;
      border: 2px solid #e2e8f0;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s ease;
      font-weight: 500;
      color: var(--text-secondary);
    }
    
    .tab:hover {
      background: #f1f5f9;
      border-color: #cbd5e1;
    }
    
    .tab.active {
      background: var(--primary);
      border-color: var(--primary);
      color: white;
    }
    
    .grade-section {
      margin-bottom: 32px;
    }
    
    .category-header {
      margin-bottom: 16px;
    }
    
    .category-title {
      font-size: 1.2rem;
      font-weight: 600;
      color: var(--text);
      margin: 0;
      padding: 16px 20px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border-radius: 8px 8px 0 0;
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
    }
    
    .table-container {
      border: 1px solid #e2e8f0;
      border-radius: 0 0 8px 8px;
      overflow: hidden;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
    }
    
    .grades-table {
      width: 100%;
      border-collapse: collapse;
      background: var(--card);
    }
    
    .grades-table th {
      background: #f8fafc;
      padding: 14px 16px;
      text-align: left;
      font-weight: 600;
      color: var(--text);
      border-bottom: 2px solid #e2e8f0;
      font-size: 0.9rem;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .grades-table td {
      padding: 14px 16px;
      border-bottom: 1px solid #f1f5f9;
      color: var(--text);
      vertical-align: middle;
    }
    
    .grades-table tbody tr:hover {
      background: #f8fafc;
    }
    
    .grades-table tbody tr:last-child td {
      border-bottom: none;
    }
    
    /* Category Entry Table Styles */
    .category-entry-container {
      background: var(--card);
      border: 1px solid #e2e8f0;
      border-radius: 12px;
      padding: 24px;
      margin-bottom: 24px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
    }

    .category-entry-container .table-wrapper {
      overflow-x: auto;
    }
    
    .category-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
      padding-bottom: 16px;
      border-bottom: 1px solid #e2e8f0;
    }
    
    .category-header h2 {
      margin: 0;
      font-size: 1.2rem;
      font-weight: 600;
      color: var(--text);
    }
    
    .category-tabs {
      display: flex;
      gap: 8px;
    }
    
    .category-tabs .tab-button {
      padding: 8px 16px;
      border: 2px solid #e2e8f0;
      background: var(--card);
      color: var(--text-secondary);
      border-radius: 6px;
      cursor: pointer;
      font-weight: 500;
      transition: all 0.2s ease;
    }
    
    .category-tabs .tab-button:hover {
      background: #f8fafc;
      border-color: #cbd5e1;
    }
    
    .category-tabs .tab-button.active {
      background: var(--primary);
      border-color: var(--primary);
      color: white;
    }
    
    .category-record-table {
      width: 100%;
      min-width: 1100px;
      border-collapse: collapse;
      background: var(--card);
    }
    
    .category-record-table th {
      background: #f8fafc;
      padding: 12px 8px;
      text-align: center;
      font-weight: 600;
      color: var(--text);
      border-bottom: 2px solid #e2e8f0;
      font-size: 0.85rem;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      vertical-align: middle;
    }

    .header-number {
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 600;
    }
    
    .category-record-table th:first-child {
      text-align: left;
      padding-left: 16px;
    }
    
    .category-record-table td {
      padding: 12px 8px;
      border-bottom: 1px solid #f1f5f9;
      color: var(--text);
      vertical-align: middle;
      text-align: center;
    }
    
    .category-record-table td:first-child {
      text-align: left;
      padding-left: 16px;
    }
    
    .category-record-table tbody tr:hover {
      background: #f8fafc;
    }

    .score-input-cell,
    .max-input-cell {
      width: 64px;
      padding: 6px 8px;
      border: 2px solid #e2e8f0;
      border-radius: 4px;
      text-align: center;
      font-size: 0.9rem;
      transition: all 0.2s ease;
    }
    
    .score-input-cell[data-formula] {
      background-color: #f0f9ff !important;
      border-color: #0ea5e9 !important;
      font-style: italic;
    }
    
    .score-input-cell[data-formula]:focus {
      border-color: #0284c7 !important;
      box-shadow: 0 0 0 3px rgba(2, 132, 199, 0.1);
    }

    .score-input-cell:focus,
    .max-input-cell:focus {
      outline: none;
      border-color: var(--primary);
      box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1);
    }
    
    /* Excel-like visual feedback */
    .saving {
      position: relative;
      background-color: #fef3c7 !important;
      border-color: #f59e0b !important;
    }
    
    .saving::after {
      content: '...';
      position: absolute;
      right: 8px;
      top: 50%;
      transform: translateY(-50%);
      color: #f59e0b;
      font-weight: bold;
      animation: pulse 1s infinite;
    }
    
    .save-success {
      background-color: #d1fae5 !important;
      border-color: #10b981 !important;
    }
    
    .save-success::after {
      content: '✓';
      position: absolute;
      right: 8px;
      top: 50%;
      transform: translateY(-50%);
      color: #10b981;
      font-weight: bold;
    }
    
    .save-error {
      background-color: #fee2e2 !important;
      border-color: #ef4444 !important;
    }
    
    .save-error::after {
      content: '✗';
      position: absolute;
      right: 8px;
      top: 50%;
      transform: translateY(-50%);
      color: #ef4444;
      font-weight: bold;
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
    
    .category-pager {
      display: flex;
      justify-content: center;
      gap: 8px;
      margin-top: 16px;
      padding-top: 16px;
      border-top: 1px solid #e2e8f0;
    }
    
    .category-pager .btn-secondary {
      padding: 6px 12px;
      border: 1px solid #e2e8f0;
      background: var(--card);
      color: var(--text-secondary);
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.85rem;
      font-weight: 500;
      transition: all 0.2s ease;
    }
    
    .category-pager .btn-secondary:hover:not(:disabled) {
      background: #f8fafc;
      border-color: #cbd5e1;
    }
    
    .category-pager .btn-secondary.active {
      background: var(--primary);
      border-color: var(--primary);
      color: white;
    }
    
    .category-pager .btn-secondary:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    .category-helper {
      margin-top: 16px;
      padding-top: 16px;
      border-top: 1px solid #e2e8f0;
    }
    
    .category-helper small {
      color: #64748b;
      font-style: italic;
    }
    
    /* Responsive adjustments */
    @media (max-width: 768px) {
      .control-card {
        padding: 16px;
      }
      
      .student-selector {
        flex-direction: column;
        align-items: stretch;
        gap: 8px;
      }
      
      .selector-label {
        min-width: auto;
      }
      
      .quarter-tabs, .tabs {
        justify-content: center;
      }
      
      .quarter-tab, .tab {
        flex: 1;
        text-align: center;
        min-width: 80px;
      }
      
      .grades-table {
        font-size: 0.85rem;
      }
      
      .grades-table th, .grades-table td {
        padding: 10px 8px;
      }
    }
  </style>
</body>
</html>